# Create Tables 


Instructor: In this video, we're gonna create database tables from Java code. So previously we created the database tables by running an SQL script and we would run that script in the MySQL Workbench. But there's another option here. Hibernate provides the option to auto automagically create the database tables for you. So it'll actually create the tables based on Java code with JPA/Hibernate annotations. And this is very useful for development and testing. So basically you have your Java code with the annotations you run it through this Hibernate tool, and then it'll actually generate the SQL and also execute that SQL and apply it on the given database. So there's no need for you to write any of the SQL. It'll actually generate and apply it on the fly, which is really cool. So in the Hibernate configuration file you'll set up this property here and you give a property value. Here we'll call it create. So when you run your application, Hibernate will drop the tables and then create them again from scratch. And this is all based on the JPA/Hibernate annotations that are in your Java code. Again, looking at our Java code, right? We have our student and we have our JPA/Hibernate annotations here. So we have at table, it'll create a table called student, and then we have ID and then we also have all of the columns. So Hibernate will use this information to actually generate the SQL and execute SQL and apply it on the given database. So Hibernate will do all of this work for you behind the scenes, which is really cool. So there's different property values that you can set here. So one value you can say is none. So in that case, no action will be performed. There's a create only, so the database tables are only created. For drop, database tables are dropped. Now, when we say drop, that means that all data is lost, everything goes away, you lose everything. So for create option, there's the database tables are dropped, followed by a database table creation. For create drop, it will drop the database tables and recreate on startup. So basically when your application finishes running, it'll actually drop the tables, so you'll have nothing at the end of the application. And this is primarily useful for unit testing. They also have the validate option to validate the database table schema. And then there's updates. So if you add any new fields to your entity, it'll provide the appropriate updates on the given database table. For ease of development and testing, we'll actually use auto configuration. So we'll make use of the property for create. And so the database tables are dropped first and then created from scratch. And so again, just a reminder, when database tables are dropped, all data is lost. But this is fine just for dev and testing. If you wanna create the tables once and then keep the data, then make you so the update config. However, be aware this will alter the database schema based on the latest code updates. Be very careful here. Only use this for basic projects because you could actually change the database schema with this configuration, and it may affect other applications using that given database. Now also, kind of my warning here, I want to just kind of full disclosure here. Disclaimer, don't do this on production databases. You don't want to drop your production data because if you drop your production data, all data is deleted. And that's a really bad position to be in as a developer and having to talk to your manager or your IT team and say, "Hey I dropped all of the production data." I understand there's backups out there and so on. But you simply don't want to be in that position of having to say, "I screwed up. I made a problem, I deleted all the data." All right? So just be very careful here. And instead, for production, you should have DBAs run SQL scripts and let them manage the production data. You wanna try and stay hands off as much as possible. Now, you may wonder, "Well, what's the use case for this configuration?" Well, automatic table generation is useful for database integration testing using in-memory databases. And it's also really good for basic hobby projects where you're the only developer working on it in a small isolated fashion. And so my recommendation here is in general I don't recommend auto generation for enterprise, real-time projects because you can very easily drop production data if you're not careful. Instead, I recommend using SQL scripts. Corporate DBAs prefer SQL scripts for governance and code reviews. The SQL scripts can be customized and fine-tuned for very complex database designs. And you can also version--control these scripts. And finally, you can make use of these SQL scripts to work with schema migration tools such as Liquibase and Flyway. The key takeaway here, table generation is very useful for small, basic hobby projects that you're working with on your own. For real-time, real world applications, make use of SQL scripts. Let's go ahead and move into the next video and let's test out this configuration. 
